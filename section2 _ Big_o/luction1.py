# Big o is the measure of the efficiency of an algorithm.
# it has two types
# 1. Time complexity: how the time taken by an algorithm increases with the size of the input.
# 2. Space complexity: how the space taken by an algorithm increases with the size of the input.

# the best case is the minimum time taken by an algorithm the sympol is Ω.
# the worst case is the maximum time taken by an algorithm the sympol is O.
# the average case is the average time taken by an algorithm the sympol is Θ.

# ex1: <> Big O: O(n)
# Implement a Python function called print_items.
# This function should take a single integer as an argument and print out a sequence of numbers from 0 up to, but not including, the provided integer.
# The function should use a for loop and Python's built-in range function to generate the sequence of numbers.
# The function signature should be: def print_items(n):

# solution:
# def print_items(n):
#     for i in range(n):
#         print(i)

#######################################################################################

# ex2: <> Big O: O(n log n)
# In this task, you are required to implement a function called print_items(n).

# <> Big O: O(n^2)
# In this task, you are required to implement a function called print_items(n).
# This function takes one integer argument, n, and prints out a pair of numbers (i, j) for every possible combination of i and j in the range of 0 up to but not including n.
# Each pair (i, j) is printed on a new line. i and j iterate over the range independently, so every combination of i and j in the range should be printed.
# The output of the function should be a series of pairs, printed one after the other, each on a new line. The pairs should be printed in the order that they are generated by the nested loops.

# the solution:
# def print_items(n):
#     for i in range(n):
#         for j in range(n):
#             print(i,j)

#######################################################################
# The expression \( O(100n^2) \) can be simplified using Big O notation rules. 
# 1. **Drop the constant coefficient**: In Big O notation, constant multipliers are ignored because they do not affect the growth rate of the function as \( n \) becomes very large.  
#    - \( O(100n^2) \) simplifies to \( O(n^2) \).
# Thus, the simplified form is:  
# **\( O(n^2) \)**
######################################################################

# The correct answer depends on the specific **Divide and Conquer** algorithm being referenced, as different implementations have different complexities. However, the most **common and representative** Big O for classic Divide and Conquer algorithms (like Merge Sort or Quick Sort in the average case) is:  
### **✅ \( O(n \log n) \)**  
# But since \( O(n \log n) \) **isn’t listed** in the options, let’s analyze the given choices:  
# 1. **\( O(1) \)** – Incorrect. Divide and Conquer does not run in constant time.  
# 2. **\( O(\log n) \)** – Correct for **Binary Search** (a special case of Divide and Conquer), but not general.  
# 3. **\( O(n^2) \)** – Correct for **worst-case Quick Sort**, but not the best representation.  
# 4. **\( O(n) \)** – Incorrect for standard Divide and Conquer (though some linear-time selections exist).  
# ### Best Answer Among Options:  
# **✅ \( O(\log n) \)** (if considering Binary Search)  
# **or \( O(n^2) \)** (if considering worst-case Quick Sort).  
# However, the question is **poorly phrased** since the "correct" answer depends on context. If forced to pick one, **\( O(\log n) \) is the most classic Divide and Conquer example (Binary Search)**.  
# Would you like clarification on a specific algorithm?